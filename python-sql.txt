+ pep249 : encourage similarity between py module to acces  database
 + v2
   + fournit objets globaux à tester
     + apilevel : doit valoir "2.0" sinon tt ce qu est en dessous est faux
     + threadsafety mouais
     +  paramstyle: (qmark (?), numeric (:=1), named (name:=name), format (name=%s) pyformat (name=%(name)s)
       + j attends qmark de pysqlite3
 + étapes :
   + connexion  (via connector  : parametre1, parametre2 .... parametren -> objet connection possédant: 
      + creer un objet recevant les demandes d'édition: cursor() -> objet curseur
        + contexte d'une opération de lecture (de lecture seulement?)
          + attributs: 
            + .description -> Liste : contient des seq avec noms des colonnes et leurs types et d autres trucs optionnels.
        + deux curseurs issus d une meme cnx ne sont pas isolés (chg par 1 visibles -avt commit?- par l autre)
        
      + valider les éditions en attente: commit() -> rien MAIS COMMITE LES EDITIONS
         + pannes:
          + si transaction existe pas sur cette db : commit() -> rien MAIS FAIT RIEN
          + si autocommit,  elle est à off par défaut. doit filer méthode pour la mettre sur "on"
      + annuler les éditions en attente : rollback() -> rien mais annule les éditions en attente.
          + pannes: deconnexion sans commit() equiv rollback()
      + fermeture de cnx : close()
     

+ plain sql
  + écrire la req à la main
  + probleme : injection sql (mouais)
  + transtypage python sql : OUI pour sqlite
  + pas indépendant de la db. la réécrire si on ch de db bof. 
  

+ python-sql
 + pep249 python databae api
  + toute bonne librairie de connexion doit appliquer l'échappement sur les paramètres
 + !orm 
   + sql générique + flavors
 + y? 
   + req dynamiques formulaire de rech avancée dynamique
   + postgres en prod vs sqlite en tet
 + w? génère la ch sql
+ sql-alchemy
 + orm : cache le sql
   + req dynamiques de rech avancées